<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Day 19 ‚Äî Container Security: ECR & ECS/Fargate</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&family=DM+Serif+Display:ital@0;1&family=DM+Sans:wght@300;400;500&display=swap" rel="stylesheet">
<link rel="stylesheet" href="shared.css">
</head>
<body>
<div class="shell">
<nav class="sidebar">
  <div class="sidebar-header">
    <div class="day-badge">Week 3 ¬∑ Day 19</div>
    <h2>Container Security:<br>ECR & ECS/Fargate</h2>
    <div class="sidebar-meta"><span class="chip">ECR</span><span class="chip">ECS</span><span class="chip">Fargate</span><span class="chip">4 lessons</span><span class="chip">1 lab</span></div>
  </div>
  <div class="sidebar-back">
    <a class="back-index" href="../index.html">
      <svg width="12" height="12" viewBox="0 0 12 12" fill="none"><path d="M7.5 2L3.5 6L7.5 10" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>
      Course Index
    </a>
    <div class="week-jumps-label">Jump to week</div>
    <div class="week-jumps">
      <a class="week-jump wj1" href="../index.html#week-1">W1</a>
      <a class="week-jump wj2" href="../index.html#week-2">W2</a>
      <a class="week-jump wj3" href="../index.html#week-3">W3</a>
      <a class="week-jump wj4" href="../index.html#week-4">W4</a>
    </div>
    <div class="day-nav-label">Week 3 days</div>
    <div class="day-nav">
      <a class="day-link" href="day-15.html">D15</a>
      <a class="day-link" href="day-16.html">D16</a>
      <a class="day-link" href="day-17.html">D17</a>
      <a class="day-link" href="day-18.html">D18</a>
      <a class="day-link current" href="day-19.html">D19</a>
      <a class="day-link" href="day-20.html">D20</a>
      <a class="day-link" href="day-21.html">D21</a>
    </div>
  </div>

  <div class="lesson-nav">
    <div class="nav-group-label">Lessons</div>
    <div class="nav-item active" onclick="goTo(0)"><span class="nav-num">01</span><span class="nav-label">Container Threat Model</span><span class="nav-check">‚úì</span></div>
    <div class="nav-item" onclick="goTo(1)"><span class="nav-num">02</span><span class="nav-label">ECR: Image Security & Access Control</span><span class="nav-check">‚úì</span></div>
    <div class="nav-item" onclick="goTo(2)"><span class="nav-num">03</span><span class="nav-label">ECS Task IAM & Secrets Management</span><span class="nav-check">‚úì</span></div>
    <div class="nav-item" onclick="goTo(3)"><span class="nav-num">04</span><span class="nav-label">Fargate Runtime Security</span><span class="nav-check">‚úì</span></div>
    <div class="nav-group-label" style="margin-top:8px">Lab</div>
    <div class="nav-item lab-item" onclick="goTo(4)"><span class="nav-num" style="color:var(--lab)">üî¨</span><span class="nav-label">Hands-on: ECR Scanning + Fargate Deployment</span><span class="nav-check">‚úì</span></div>
  </div>
  <div class="sidebar-footer">
    <div class="progress-label"><span>Progress</span><span id="progress-pct">0 / 5</span></div>
    <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
  </div>
</nav>
<div class="main">
  <div class="lesson-topbar">
    <div class="lesson-crumb">Day 19 &nbsp;/&nbsp; <span id="topbar-title">Container Threat Model</span></div>
    <div class="nav-arrows">
      <button class="arrow-btn" id="btn-prev" onclick="prev()" disabled>‚Üê Prev</button>
      <button class="arrow-btn" id="btn-next" onclick="next()">Next ‚Üí</button>
    </div>
  </div>

  <!-- LESSON 1 -->
  <div class="lesson-pane active" id="pane-0">
    <div class="lesson-tag tag-security">Container Security ¬∑ Foundational</div>
    <h1>Container<br><em>Threat Model</em></h1>
    <p>Containers share the host OS kernel ‚Äî unlike VMs which have fully isolated kernels. This changes the threat model fundamentally: a container escape vulnerability in the container runtime can give an attacker access to the host and every other container on it.</p>
    <p>The container security surface spans four distinct layers, each with its own controls:</p>
    <div class="flow-steps">
      <div class="flow-step"><div class="flow-num">1</div><div class="flow-body"><strong>Image supply chain</strong> ‚Äî vulnerable packages in the base image, secrets accidentally baked in, outdated OS layers. Controlled at build time with scanning and hardened base images.</div></div>
      <div class="flow-step"><div class="flow-num">2</div><div class="flow-body"><strong>Registry access</strong> ‚Äî who can push/pull images, and can untrusted images enter your pipeline? Controlled via ECR repository policies and image signing.</div></div>
      <div class="flow-step"><div class="flow-num">3</div><div class="flow-body"><strong>Runtime identity</strong> ‚Äî what IAM permissions does the running container have? Controlled via ECS Task IAM roles (least-privilege, no EC2 instance profile bleed-through).</div></div>
      <div class="flow-step"><div class="flow-num">4</div><div class="flow-body"><strong>Runtime behaviour</strong> ‚Äî can the container modify the host filesystem, escalate privileges, or call the metadata service? Controlled via Fargate (no host access), read-only root FS, and security options.</div></div>
    </div>
    <div class="callout breach">
      <div class="callout-title">‚ö† Real Breach ‚Äî Tesla Cryptojacking (2018)</div>
      Attackers found an unsecured Kubernetes dashboard with no authentication. They deployed a container running a cryptominer using the pod's IAM role to access Tesla's AWS environment. The container had a permissive IAM role (inherited from the EC2 node) that allowed S3 access. Fargate isolates this: each task gets its own IAM role and there is no shared EC2 instance profile to inherit.
    </div>
    <div class="callout insight">
      <div class="callout-title">üí° Fargate vs. EC2 Launch Type ‚Äî Security Perspective</div>
      EC2 launch type: you manage the host, patch the OS, control instance profiles that all containers on the node share. Fargate: AWS manages the host completely, each task is isolated in its own micro-VM (Firecracker), and IAM is per-task only. For security, Fargate is almost always preferable ‚Äî you trade infrastructure control for a dramatically reduced attack surface.
    </div>
    <div class="kcheck">
      <div class="kcheck-label">Knowledge Check</div>
      <div class="kcheck-q">A developer accidentally commits AWS credentials into a Docker image that gets pushed to ECR and deployed to production. What's the correct order of remediation steps?</div>
      <div class="kcheck-options">
        <button class="kcheck-opt" onclick="check(this,false,0)"><span class="opt-key">A</span>Delete the ECR image, then rotate the credentials ‚Äî removing the image removes the exposure</button>
        <button class="kcheck-opt" onclick="check(this,true,0)"><span class="opt-key">B</span>Rotate/revoke the credentials immediately (assume compromised), then remove the image from ECR and all running tasks, then audit CloudTrail for any usage of the leaked keys</button>
        <button class="kcheck-opt" onclick="check(this,false,0)"><span class="opt-key">C</span>Mark the image as private in ECR ‚Äî this prevents further pulls and contains the exposure</button>
        <button class="kcheck-opt" onclick="check(this,false,0)"><span class="opt-key">D</span>Rebuild and redeploy the image without the credentials ‚Äî existing running containers are unaffected once the image is removed from ECR</button>
      </div>
      <div class="kcheck-feedback" id="fb-0"></div>
    </div>
    <div class="lesson-nav-footer"><button class="prev-btn" disabled>‚Üê Previous</button><button class="next-btn" onclick="next()">Next Lesson ‚Üí</button></div>
  </div>

  <!-- LESSON 2 -->
  <div class="lesson-pane" id="pane-1">
    <div class="lesson-tag tag-concept">ECR Security ¬∑ Foundational</div>
    <h1>ECR: Image Security<br><em>& Access Control</em></h1>
    <p><strong>Objective:</strong> Secure the ECR registry ‚Äî who can push/pull, how images are scanned for CVEs, and how to enforce that only scanned-and-approved images reach production.</p>
    <table class="styled-table">
      <thead><tr><th>Control</th><th>What it does</th><th>Where configured</th></tr></thead>
      <tbody>
        <tr><td>Repository policy</td><td>Resource-based policy controlling push/pull permissions per repo</td><td>ECR repository ‚Üí Permissions</td></tr>
        <tr><td>Enhanced scanning</td><td>Inspector continuously scans images on push and on new CVE publication</td><td>ECR ‚Üí Scanning configuration</td></tr>
        <tr><td>Lifecycle policy</td><td>Auto-delete old/untagged images to reduce CVE surface</td><td>ECR repository ‚Üí Lifecycle policy</td></tr>
        <tr><td>Image immutability</td><td>Prevents overwriting an existing tag ‚Äî enforces content-addressable deploys</td><td>ECR repository ‚Üí Image tag mutability</td></tr>
        <tr><td>Encryption</td><td>Images encrypted at rest with AES-256 (default) or your KMS CMK</td><td>ECR repository ‚Üí Encryption settings</td></tr>
      </tbody>
    </table>
    <div class="code-block">
      <div class="code-header"><span class="code-lang">JSON ‚Äî ECR Repository Policy: Only CI/CD Role Can Push</span><button class="copy-btn" onclick="copyCode(this)">copy</button></div>
      <pre>{
  <span class="key">"Version"</span>: <span class="str">"2012-10-17"</span>,
  <span class="key">"Statement"</span>: [
    {
      <span class="comment">// Only the CI/CD role can push images</span>
      <span class="hl">"Sid"</span>: <span class="str">"AllowCICDPush"</span>,
      <span class="hl">"Effect"</span>: <span class="str">"Allow"</span>,
      <span class="hl">"Principal"</span>: { <span class="str">"AWS"</span>: <span class="str">"arn:aws:iam::123456789012:role/GitHubActionsCI"</span> },
      <span class="hl">"Action"</span>: [
        <span class="str">"ecr:GetDownloadUrlForLayer"</span>, <span class="str">"ecr:BatchGetImage"</span>,
        <span class="str">"ecr:BatchCheckLayerAvailability"</span>, <span class="str">"ecr:PutImage"</span>,
        <span class="str">"ecr:InitiateLayerUpload"</span>, <span class="str">"ecr:UploadLayerPart"</span>,
        <span class="str">"ecr:CompleteLayerUpload"</span>
      ]
    },
    {
      <span class="comment">// ECS task execution role can pull (read-only)</span>
      <span class="hl">"Sid"</span>: <span class="str">"AllowECSPull"</span>,
      <span class="hl">"Effect"</span>: <span class="str">"Allow"</span>,
      <span class="hl">"Principal"</span>: { <span class="str">"AWS"</span>: <span class="str">"arn:aws:iam::123456789012:role/ecsTaskExecutionRole"</span> },
      <span class="hl">"Action"</span>: [
        <span class="str">"ecr:GetDownloadUrlForLayer"</span>, <span class="str">"ecr:BatchGetImage"</span>,
        <span class="str">"ecr:BatchCheckLayerAvailability"</span>
      ]
    }
  ]
}</pre>
    </div>
    <div class="callout tip">
      <div class="callout-title">‚úì Enable Image Tag Immutability</div>
      Set ECR repositories to <strong>IMMUTABLE</strong> tag mutability. This prevents a developer from pushing a new image with the same tag (e.g. <code>latest</code> or <code>v1.2.3</code>) and silently replacing what production is running. Every image version gets a unique immutable tag ‚Äî you always know exactly what code is deployed.
    </div>
    <div class="kcheck">
      <div class="kcheck-label">Knowledge Check</div>
      <div class="kcheck-q">Your CI pipeline pushes an image tagged <code>production-latest</code> to ECR with MUTABLE tags enabled. A junior developer accidentally runs the same push command with broken code, overwriting the tag. Production pods restart and pull the broken image. Which ECR setting would have prevented this?</div>
      <div class="kcheck-options">
        <button class="kcheck-opt" onclick="check(this,false,1)"><span class="opt-key">A</span>A lifecycle policy ‚Äî it prevents images from being overwritten after 30 days</button>
        <button class="kcheck-opt" onclick="check(this,true,1)"><span class="opt-key">B</span>Image tag immutability set to IMMUTABLE ‚Äî once a tag is pushed, it cannot be overwritten; the developer's push would have failed with an error</button>
        <button class="kcheck-opt" onclick="check(this,false,1)"><span class="opt-key">C</span>Enhanced scanning ‚Äî it would have caught the broken image before it reached production</button>
        <button class="kcheck-opt" onclick="check(this,false,1)"><span class="opt-key">D</span>Encrypting the repository ‚Äî encrypted repos require explicit permission to overwrite tags</button>
      </div>
      <div class="kcheck-feedback" id="fb-1"></div>
    </div>
    <div class="lesson-nav-footer"><button class="prev-btn" onclick="prev()">‚Üê Previous</button><button class="next-btn" onclick="next()">Next Lesson ‚Üí</button></div>
  </div>

  <!-- LESSON 3 -->
  <div class="lesson-pane" id="pane-2">
    <div class="lesson-tag tag-security">IAM & Secrets ¬∑ Intermediate</div>
    <h1>ECS Task IAM<br><em>& Secrets Management</em></h1>
    <p><strong>Objective:</strong> Understand the two ECS IAM roles, why they must be separate and least-privilege, and how to inject secrets into containers without baking them into images or environment variables.</p>
    <div class="compare-grid">
      <div class="compare-card ok">
        <div class="compare-card-head">üîß Task Execution Role</div>
        <div class="compare-card-body">
          <strong>Used by the ECS agent, not your code</strong>
          Pulls the image from ECR, fetches secrets from Secrets Manager or SSM Parameter Store, writes logs to CloudWatch.<br><br>
          Needs: <code>ecr:GetDownloadUrlForLayer</code>, <code>logs:CreateLogStream</code>, <code>secretsmanager:GetSecretValue</code>
        </div>
      </div>
      <div class="compare-card warn">
        <div class="compare-card-head">‚öôÔ∏è Task Role</div>
        <div class="compare-card-body">
          <strong>Used by your application code</strong>
          The IAM permissions your running container process actually has ‚Äî S3 reads, DynamoDB writes, SQS sends.<br><br>
          Must be <strong>strictly least-privilege</strong>. A compromised container only has these permissions.
        </div>
      </div>
    </div>
    <div class="callout warning">
      <div class="callout-title">‚ö† Never Use Environment Variables for Secrets</div>
      Secrets in ECS environment variables appear in plaintext in the task definition JSON (visible in the console, CLI, and CloudTrail), in container inspect output, and in any process that dumps environment variables. Always use Secrets Manager or SSM Parameter Store ‚Äî the ECS agent fetches and injects the value at container start, and it's never stored in the task definition.
    </div>
    <div class="code-block">
      <div class="code-header"><span class="code-lang">JSON ‚Äî ECS Task Definition: Secrets from Secrets Manager</span><button class="copy-btn" onclick="copyCode(this)">copy</button></div>
      <pre>{
  <span class="key">"containerDefinitions"</span>: [{
    <span class="hl">"name"</span>: <span class="str">"app"</span>,
    <span class="hl">"image"</span>: <span class="str">"123456789012.dkr.ecr.us-east-1.amazonaws.com/myapp:v1.2.3"</span>,
    <span class="comment">// Secrets injected at container start ‚Äî never in task definition plaintext</span>
    <span class="hl">"secrets"</span>: [
      {
        <span class="str">"name"</span>: <span class="str">"DB_PASSWORD"</span>,
        <span class="str">"valueFrom"</span>: <span class="str">"arn:aws:secretsmanager:us-east-1:123456789:secret:prod/db/password"</span>
      },
      {
        <span class="str">"name"</span>: <span class="str">"API_KEY"</span>,
        <span class="str">"valueFrom"</span>: <span class="str">"arn:aws:ssm:us-east-1:123456789:parameter/prod/api-key"</span>
      }
    ],
    <span class="comment">// Block privilege escalation at the container level</span>
    <span class="hl">"linuxParameters"</span>: {
      <span class="str">"initProcessEnabled"</span>: true
    },
    <span class="hl">"readonlyRootFilesystem"</span>: true,
    <span class="hl">"user"</span>: <span class="str">"1000:1000"</span>  <span class="comment">// non-root user</span>
  }]
}</pre>
    </div>
    <div class="kcheck">
      <div class="kcheck-label">Knowledge Check</div>
      <div class="kcheck-q">Your ECS task needs to read from S3. A developer suggests adding <code>s3:*</code> on <code>arn:aws:s3:::*</code> to the Task Role for simplicity. What's the security problem?</div>
      <div class="kcheck-options">
        <button class="kcheck-opt" onclick="check(this,false,2)"><span class="opt-key">A</span>No problem ‚Äî the Task Role only applies to containers, not to the underlying EC2 host</button>
        <button class="kcheck-opt" onclick="check(this,true,2)"><span class="opt-key">B</span>If the container is compromised, the attacker inherits <code>s3:*</code> on all buckets ‚Äî including sensitive buckets like logs, backups, and PCI data. The Task Role should allow only <code>s3:GetObject</code> on the specific bucket the app needs</button>
        <button class="kcheck-opt" onclick="check(this,false,2)"><span class="opt-key">C</span>ECS Task Roles don't support S3 access ‚Äî you must use the Task Execution Role for all AWS API calls</button>
        <button class="kcheck-opt" onclick="check(this,false,2)"><span class="opt-key">D</span>The Task Role only applies while the container is running ‚Äî once terminated, access is revoked automatically</button>
      </div>
      <div class="kcheck-feedback" id="fb-2"></div>
    </div>
    <div class="lesson-nav-footer"><button class="prev-btn" onclick="prev()">‚Üê Previous</button><button class="next-btn" onclick="next()">Next Lesson ‚Üí</button></div>
  </div>

  <!-- LESSON 4 -->
  <div class="lesson-pane" id="pane-3">
    <div class="lesson-tag tag-ops">Runtime Security ¬∑ Intermediate</div>
    <h1>Fargate<br><em>Runtime Security</em></h1>
    <p><strong>Objective:</strong> Understand Fargate's security model, the runtime hardening controls available in ECS task definitions, and how immutable containers differ from mutable VM-style workloads.</p>
    <p>Fargate runs each task in an isolated <strong>Firecracker microVM</strong> ‚Äî a lightweight virtual machine with its own kernel, managed entirely by AWS. You have no SSH access, no host OS to patch, and no shared kernel with other tenants. This eliminates an entire class of attacks at the cost of reduced operational visibility.</p>
    <table class="styled-table">
      <thead><tr><th>Hardening control</th><th>How to enable</th><th>What it prevents</th></tr></thead>
      <tbody>
        <tr><td>Read-only root FS</td><td><code>"readonlyRootFilesystem": true</code> in task def</td><td>Attacker writing malware, modifying binaries</td></tr>
        <tr><td>Non-root user</td><td><code>"user": "1000:1000"</code> in task def</td><td>UID 0 privilege escalation inside container</td></tr>
        <tr><td>No new privileges</td><td><code>"noNewPrivileges": true</code> in linuxParameters</td><td>setuid binaries elevating container permissions</td></tr>
        <tr><td>Drop capabilities</td><td><code>"drop": ["ALL"]</code> in capabilities</td><td>Raw network access, filesystem mounting, kernel calls</td></tr>
        <tr><td>Block IMDS access</td><td>Set hop limit to 1 on underlying EC2 (EC2 launch type) or use Fargate (no IMDS)</td><td>Container stealing EC2 instance credentials</td></tr>
      </tbody>
    </table>
    <div class="callout tip">
      <div class="callout-title">‚úì Immutable Container Philosophy</div>
      In a properly designed container deployment, you never patch a running container ‚Äî you build a new image with the fix, scan it, push it to ECR, and redeploy. Running containers are immutable artefacts. This means a read-only root filesystem is a natural fit: if the application needs to write state, it does so to a mounted volume or external service ‚Äî not to its own filesystem.
    </div>
    <div class="kcheck">
      <div class="kcheck-label">Knowledge Check</div>
      <div class="kcheck-q">A Fargate task is running as root (UID 0) with a read-write root filesystem. The containerised app has an RCE vulnerability. What can the attacker do inside the Fargate task?</div>
      <div class="kcheck-options">
        <button class="kcheck-opt" onclick="check(this,false,3)"><span class="opt-key">A</span>Nothing beyond the container ‚Äî Fargate's Firecracker isolation prevents any impact even for root processes</button>
        <button class="kcheck-opt" onclick="check(this,true,3)"><span class="opt-key">B</span>Read and modify all files in the container, install tools, call AWS APIs using the Task Role credentials, and potentially exploit container runtime vulnerabilities ‚Äî root + RW filesystem maximises the blast radius inside the task boundary</button>
        <button class="kcheck-opt" onclick="check(this,false,3)"><span class="opt-key">C</span>Only read files ‚Äî a read-write filesystem doesn't grant write access to a container running in Fargate</button>
        <button class="kcheck-opt" onclick="check(this,false,3)"><span class="opt-key">D</span>Access the EC2 host ‚Äî Fargate tasks run on EC2 instances and root containers can access the host filesystem</button>
      </div>
      <div class="kcheck-feedback" id="fb-3"></div>
    </div>
    <div class="lesson-nav-footer"><button class="prev-btn" onclick="prev()">‚Üê Previous</button><button class="next-btn lab-btn" onclick="next()">Start Lab ‚Üí</button></div>
  </div>

  <!-- LAB -->
  <div class="lesson-pane lab-pane" id="pane-4">
    <div class="lesson-tag tag-lab">üî¨ Hands-On Lab</div>
    <h1>ECR Scanning +<br><em>Fargate Deployment</em></h1>
    <p>Create an ECR repository with enhanced scanning and immutable tags, push a sample image, review Inspector findings, then deploy it as a hardened Fargate task with a least-privilege Task Role and secrets from Secrets Manager.</p>
    <div class="callout lab-note"><div class="callout-title">‚ö° Cost Note</div>ECR storage: $0.10/GB/month ‚Äî a small image is negligible. Fargate: ~$0.04048/vCPU-hour + $0.004445/GB-hour. Run the task for verification only (~5 min) then stop it. Total lab cost under $0.05. Delete all resources with the cleanup script.</div>
    <div class="lab-steps">
      <div class="lab-step">
        <div class="step-num-wrap"><div class="step-num">1</div><div class="step-connector"></div></div>
        <div class="step-content">
          <div class="step-title">Create ECR Repo with Security Settings <span style="font-size:12px;color:var(--muted);font-family:'IBM Plex Mono',monospace">~10 min</span></div>
          <div class="step-body">
            <div class="code-block">
              <div class="code-header"><span class="code-lang">bash</span><button class="copy-btn" onclick="copyCode(this)">copy</button></div>
              <pre><span class="comment"># Create repo with immutable tags and KMS encryption</span>
aws ecr create-repository \
  --repository-name <span class="str">sec-lab-app</span> \
  --image-tag-mutability <span class="hl">IMMUTABLE</span> \
  --image-scanning-configuration <span class="str">scanOnPush=true</span> \
  --encryption-configuration encryptionType=<span class="hl">KMS</span>

<span class="comment"># Enable Enhanced Scanning (Inspector) for all repos</span>
aws ecr put-registry-scanning-configuration \
  --scan-type <span class="hl">ENHANCED</span> \
  --rules <span class="str">'[{"repositoryFilters":[{"filter":"*","filterType":"WILDCARD"}],"scanFrequency":"CONTINUOUS_SCAN"}]'</span></pre>
            </div>
          </div>
        </div>
      </div>
      <div class="lab-step">
        <div class="step-num-wrap"><div class="step-num">2</div><div class="step-connector"></div></div>
        <div class="step-content">
          <div class="step-title">Build & Push a Sample Image <span style="font-size:12px;color:var(--muted);font-family:'IBM Plex Mono',monospace">~10 min</span></div>
          <div class="step-body">
            <div class="code-block">
              <div class="code-header"><span class="code-lang">dockerfile + bash</span><button class="copy-btn" onclick="copyCode(this)">copy</button></div>
              <pre><span class="comment"># Dockerfile ‚Äî minimal hardened nginx</span>
cat > Dockerfile << <span class="str">'EOF'</span>
FROM nginx:alpine
RUN addgroup -S appgroup && adduser -S appuser -G appgroup
USER appuser
EXPOSE 8080
<span class="str">EOF</span>

<span class="comment"># Authenticate to ECR</span>
aws ecr get-login-password --region us-east-1 | \
  docker login --username AWS --password-stdin \
  <span class="hl">123456789012</span>.dkr.ecr.us-east-1.amazonaws.com

<span class="comment"># Build and push</span>
docker build -t sec-lab-app:v1.0.0 .
docker tag sec-lab-app:v1.0.0 \
  <span class="hl">123456789012</span>.dkr.ecr.us-east-1.amazonaws.com/sec-lab-app:<span class="str">v1.0.0</span>
docker push \
  <span class="hl">123456789012</span>.dkr.ecr.us-east-1.amazonaws.com/sec-lab-app:<span class="str">v1.0.0</span></pre>
            </div>
          </div>
        </div>
      </div>
      <div class="lab-step">
        <div class="step-num-wrap"><div class="step-num">3</div><div class="step-connector"></div></div>
        <div class="step-content">
          <div class="step-title">Review Inspector Findings for the Image <span style="font-size:12px;color:var(--muted);font-family:'IBM Plex Mono',monospace">~10 min</span></div>
          <div class="step-body">
            <ol>
              <li>ECR Console ‚Üí <strong>sec-lab-app</strong> ‚Üí Images ‚Üí click <strong>v1.0.0</strong></li>
              <li>Review the <strong>Vulnerabilities</strong> tab ‚Äî note Critical/High counts</li>
              <li>Inspector Console ‚Üí Findings ‚Üí filter by ECR image URI ‚Üí export top 5 findings</li>
              <li>Screenshot: image findings summary with severity breakdown</li>
            </ol>
          </div>
        </div>
      </div>
      <div class="lab-step">
        <div class="step-num-wrap"><div class="step-num">4</div><div class="step-connector"></div></div>
        <div class="step-content">
          <div class="step-title">Deploy Hardened Fargate Task <span style="font-size:12px;color:var(--muted);font-family:'IBM Plex Mono',monospace">~15 min</span></div>
          <div class="step-body">
            <ol>
              <li>ECS Console ‚Üí Create cluster ‚Üí <strong>AWS Fargate</strong> (serverless)</li>
              <li>Create Task Definition: Fargate, 0.25 vCPU / 0.5 GB RAM</li>
              <li>Container: your ECR image <code>v1.0.0</code>, <code>readonlyRootFilesystem: true</code>, <code>user: 1000:1000</code></li>
              <li>Task Role: create a minimal IAM role with only <code>logs:CreateLogStream</code> + <code>logs:PutLogEvents</code></li>
              <li>Run task in your Day 15 VPC private subnet with <code>sg-app</code></li>
              <li>Verify task reaches RUNNING state ‚Üí stop task immediately</li>
            </ol>
          </div>
        </div>
      </div>
      <div class="lab-step">
        <div class="step-num-wrap"><div class="step-num">5</div></div>
        <div class="step-content">
          <div class="step-title">Screenshot & Cleanup <span style="font-size:12px;color:var(--muted);font-family:'IBM Plex Mono',monospace">~5 min</span></div>
          <div class="step-body">
            <div class="code-block">
              <div class="code-header"><span class="code-lang">bash</span><button class="copy-btn" onclick="copyCode(this)">copy</button></div>
              <pre><span class="comment"># Delete ECR images and repository</span>
aws ecr batch-delete-image --repository-name sec-lab-app \
  --image-ids imageTag=v1.0.0
aws ecr delete-repository --repository-name sec-lab-app --force

git add screenshots/day-19-*.png
git commit -m <span class="str">"Day 19: ECR enhanced scanning, immutable tags, hardened Fargate task"</span>
git push</pre>
            </div>
          </div>
        </div>
      </div>
    </div>
    <h2 style="font-family:'DM Serif Display',serif;font-size:20px;color:#e4eaf6;margin:32px 0 16px;font-weight:400">Lab Checklist</h2>
    <div class="checklist-progress"><div class="checklist-progress-bar"><div class="checklist-progress-fill" id="cl-fill"></div></div><span class="checklist-progress-label" id="cl-label">0 / 7</span></div>
    <div class="checklist">
      <div class="check-item" onclick="toggleCheck(this,0)"><div class="check-box">‚úì</div><div class="check-text">ECR repository created with IMMUTABLE tags and Enhanced (Inspector) scanning</div></div>
      <div class="check-item" onclick="toggleCheck(this,1)"><div class="check-box">‚úì</div><div class="check-text">Docker image built with non-root user and pushed to ECR</div></div>
      <div class="check-item" onclick="toggleCheck(this,2)"><div class="check-box">‚úì</div><div class="check-text">Inspector findings reviewed for the ECR image; severity breakdown documented</div></div>
      <div class="check-item" onclick="toggleCheck(this,3)"><div class="check-box">‚úì</div><div class="check-text">ECS Fargate task definition created with <code>readonlyRootFilesystem</code> and non-root user</div></div>
      <div class="check-item" onclick="toggleCheck(this,4)"><div class="check-box">‚úì</div><div class="check-text">Task Role uses least-privilege (logs only) ‚Äî no wildcard S3 or Admin permissions</div></div>
      <div class="check-item" onclick="toggleCheck(this,5)"><div class="check-box">‚úì</div><div class="check-text">Fargate task reached RUNNING state in private subnet; stopped immediately after verification</div></div>
      <div class="check-item" onclick="toggleCheck(this,6)"><div class="check-box">‚úì</div><div class="check-text">ECR repository deleted; screenshots committed to GitHub</div></div>
    </div>
    <div class="lesson-nav-footer"><button class="prev-btn" onclick="prev()">‚Üê Previous</button><button class="next-btn lab-btn" onclick="finish()">Complete Day 19 ‚úì</button></div>
  </div>

  <!-- COMPLETION -->
  <div class="lesson-pane" id="pane-complete">
    <div class="completion-card">
      <span class="completion-icon">üì¶</span>
      <h1>Day 19 Complete</h1>
      <p>Containers secured at the image, registry, identity, and runtime layers. Day 20 extends this to serverless Lambda functions and EKS pod security ‚Äî the two remaining workload types.</p>
      <div class="score-pill"><span>‚ö°</span> Quiz: <span id="score-val">‚Äî</span></div><br>
      <div class="lab-score-pill"><span>üî¨</span> Lab: <span id="lab-score-val">‚Äî</span> complete</div>
      <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap">
        <a href="day-18.html" style="text-decoration:none"><button class="prev-btn">‚Üê Day 18</button></a>
        <a href="day-20.html" style="text-decoration:none"><button class="next-btn">Day 20 ‚Üí</button></a>
      </div>
    </div>
  </div>
</div>
</div>
<script src="csm-core.js"></script>
<script>
initPage({
  storageKey: 'csm-day19',
  total: 5,
  quizCount: 4,
  checkTotal: 7,
  titles: ['Container Threat Model','ECR: Image Security & Access Control','ECS Task IAM & Secrets Management','Fargate Runtime Security','Hands-on: ECR Scanning + Fargate Deployment'],
  fb: {
  0:{good:"Correct. The credentials are the active threat ‚Äî the image is just a record. Credentials must be rotated/revoked first (assume they've already been used), because even after image deletion, any attacker who pulled the image before deletion still has a copy. After revoking credentials, remove the image and all running task versions, then audit CloudTrail for any API calls made with the leaked keys in the window between push and revocation.",bad:"Not quite. Deleting the image first is the wrong order ‚Äî someone may have already pulled it. The credentials are the active attack vector and must be revoked immediately. The image contains the evidence of the credential, but the credential itself is the live threat. Assume the credentials are already compromised and in use: rotate/revoke first, then remove all copies of the image, then audit for any usage."},
  1:{good:"Correct. Image tag immutability (IMMUTABLE) prevents any push from overwriting an existing tag. The developer's push of a new image to an existing tag would fail immediately with an error, and the production <code>production-latest</code> tag would remain pointing to the original known-good image. This is a fundamental supply chain security control ‚Äî you always know exactly what is deployed.",bad:"Not quite. Lifecycle policies manage image retention over time ‚Äî they don't prevent tag overwrites. Enhanced scanning catches CVEs in image content, not accidental overwrites. Encryption doesn't affect tag mutability. The specific setting is Image tag mutability ‚Üí IMMUTABLE. Once set, no push can overwrite an existing tag ‚Äî the developer would get an error and the production image would be protected."},
  2:{good:"Correct. The Task Role's permissions define the blast radius of a container compromise. With <code>s3:*</code> on all buckets, a compromised container can read logs, backups, PCI data, and any other S3 content in the account ‚Äî far beyond what the app needs. Least-privilege means <code>s3:GetObject</code> on the specific ARN of the one bucket the app reads. This limits a compromise to only the data the app legitimately accesses.",bad:"Not quite. The Task Role applies directly to the running container process ‚Äî any code the container executes (including attacker code after a compromise) inherits these permissions. <code>s3:*</code> on all resources gives a compromised container full read/write/delete access to every S3 bucket in the account. Task Role permissions must be scoped to exactly the actions and resources the application legitimately needs ‚Äî nothing more."},
  3:{good:"Correct. Running as root with a read-write filesystem maximises what an attacker can do after achieving RCE. They can: install tools (curl, ncat, crypto miners) on the RW filesystem, modify application binaries, read all files including credentials and configs, make AWS API calls using the Task Role, and attempt container runtime exploits with root privileges. Fargate's Firecracker boundary limits escape to the host, but the blast radius inside the task is as large as possible.",bad:"Not quite. Fargate's Firecracker isolation limits host escape, but within the task boundary, root + RW filesystem means maximum attacker capability. They can install tools, modify files, persist malware, read all container secrets and credentials, and call AWS APIs with the Task Role. The goal of hardening (non-root user + read-only FS) is to minimise what an attacker can do after achieving code execution ‚Äî Fargate isolation alone is not sufficient."}
}
});
</script>
</body>
</html>
